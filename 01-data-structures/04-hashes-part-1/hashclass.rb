require_relative 'hash_item'

class HashClass

  def initialize(size)
    @items = Array.new(size)
  end

  def []=(key, value)
    #if there is already an item where we want to put this new item,
    #double the size of the array. keep doing that as long as there
    #is an item at the index where we want to put the new item

    while @items[index(key, size)] && @items[index(key, size)].value !=value
      resize
    end

    #when the index for the new item is vacant, slot it in
    @items[index(key, size)] = HashItem.new(key, value)
    #puts " #{@items}"
  end

  #return the item at the index of the internal array generated by
  #hashing the key with #index
  def [](key)
    @items[index(key, size)].value
  end

  #create a new array that is twice the size of the old one, and put
  #everything back in, in its updated position
  def resize
    doubled = Array.new(size*2)
    @items.each do |item|
      if item
        doubled[index(item.key, doubled.length)] = item
        #puts "item: #{item.key} \n#{doubled}"
      end
    end
    @items = doubled
  end

  # Returns a unique, deterministically reproducible index into an array
  # We are hashing based on strings, let's use the ascii value of each string as
  # a starting point.
  def index(key, size)
    #sums up the ascii values of each char in a string
    code = key.sum
    return code % size
  end

  # Simple method to return the number of items in the hash
  def size
    @items.length
  end

end

movie = HashClass.new(3)
